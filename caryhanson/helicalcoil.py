#!/usr/bin/env python3

"""This module contains a class for representing a helical coil, or
set of associated helical coils.

"""

import numpy as np
from .general import mu0

class HelicalCoil:
    """This class represents a magnetic field generated by one or more
    helical coils.

    """
    def __init__(self, m0=5, l0=2, B0=1, R0=1, r=0.3, n2pi=2, nphi=400,
                 I=np.array([-1, 1]) * 0.021, A=[[0, np.pi/2]], B=[[0, 0]]):
        self.m0 = m0
        self.nfp = m0
        self.l0 = l0
        self.B0 = B0
        self.R0 = R0
        self.r = r
        self.n2pi = n2pi
        self.nphi = nphi
        self.I = np.array(I)
        self.A = np.array(A)
        self.B = np.array(B)

        self.update()

    def update(self):
        """
        Does some initialization required before computing B.
        """
        assert self.A.shape == self.B.shape
        assert len(self.I) == self.A.shape[1]
        
        self.ncoils = len(self.I)
        self.phi = np.linspace(0, 2 * np.pi * self.n2pi, self.nphi, endpoint=False)
        self.dphi = self.phi[1] - self.phi[0]
        phi_big = np.kron(np.ones((self.ncoils, 1)), self.phi).transpose()
        cosphi = np.cos(phi_big)
        sinphi = np.sin(phi_big)
        eta = np.zeros((self.nphi, self.ncoils))
        d_eta_d_phi = np.zeros((self.nphi, self.ncoils))
        # eta(phi) is defined in eq (6) of Hanson & Cary (1984).
        for jcoil in range(self.ncoils):
            eta[:, jcoil] = self.m0 * self.phi / self.l0 + self.A[0, jcoil]
            d_eta_d_phi[:, jcoil] = self.m0 / self.l0
            for k in range(1, self.A.shape[0]):
                fac = k * self.m0 / self.l0
                eta[:, jcoil] += self.A[k, jcoil] * np.cos(fac * self.phi) \
                    + self.B[k, jcoil] * np.sin(fac * self.phi)
                d_eta_d_phi[:, jcoil] += -self.A[k, jcoil] * np.sin(fac * self.phi) * fac \
                    + self.B[k, jcoil] * np.cos(fac * self.phi) * fac
        coseta = np.cos(eta)
        sineta = np.sin(eta)
        self.R_coil = self.R0 + self.r * coseta
        self.X_coil = self.R_coil * cosphi
        self.Y_coil = self.R_coil * sinphi
        self.Z_coil = -self.r * sineta
        self.d_X_d_phi_coil = self.R_coil * (-sinphi) + self.r * (-sineta) * d_eta_d_phi * cosphi
        self.d_Y_d_phi_coil = self.R_coil *   cosphi  + self.r * (-sineta) * d_eta_d_phi * sinphi
        self.d_Z_d_phi_coil = -self.r * coseta * d_eta_d_phi
        self.factor = self.dphi

    def BR_Bphi_BZ(self, R, phi, Z):
        """
        Return the cylindrical components of the magnetic field at a specified point.
        This subroutine only works for single points as arguments.
        """
        #print("BR_Bphi_BZ called with R=%g, phi=%g, Z=%g" % (R, phi, Z))

        cosphi = np.cos(phi)
        sinphi = np.sin(phi)
        X = R * cosphi
        Y = R * sinphi

        dX = X - self.X_coil
        dY = Y - self.Y_coil
        dZ = Z - self.Z_coil

        r2 = dX * dX + dY * dY + dZ * dZ
        one_over_r3 = 1 / (r2 * np.sqrt(r2))

        # Biot-Savart law:
        BX = self.factor * np.sum(self.I * np.sum(one_over_r3 * (self.d_Y_d_phi_coil * dZ - self.d_Z_d_phi_coil * dY), axis=0))
        BY = self.factor * np.sum(self.I * np.sum(one_over_r3 * (self.d_Z_d_phi_coil * dX - self.d_X_d_phi_coil * dZ), axis=0))
        BZ = self.factor * np.sum(self.I * np.sum(one_over_r3 * (self.d_X_d_phi_coil * dY - self.d_Y_d_phi_coil * dX), axis=0))

        # Convert to cylindrical components:
        BR   =  BX * cosphi + BY * sinphi
        Bphi = -BX * sinphi + BY * cosphi + self.B0 * self.R0 / R
        # In that last term we add the toroidal field.

        return (BR, Bphi, BZ)

    @classmethod
    def optimized(cls, *args, **kwargs):
        """
        Return the optimized helical coil shape from Hanson & Cary (1984).
        """
        A = [[0, np.pi / 2], \
             [0, 0.224859], \
             [0, 0], \
             [0, -0.000856]]
        
        B = [[0, 0], \
             [0.243960, 0], \
             [0.026240, -0.026490], \
             [0.000856, 0]]

        hc = cls(A=A, B=B, *args, **kwargs)
        return hc
