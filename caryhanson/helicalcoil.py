#!/usr/bin/env python3

"""This module contains a class for representing a helical coil, or
set of associated helical coils.

"""

# These next 2 lines tell jax to use double precision:                                                                     
from jax.config import config                                                                                             
config.update("jax_enable_x64", True)

import numpy as np
from .general import mu0
from .field import Field
import jax.numpy as jnp                                                                                                   
#import numpy as jnp
from jax import grad, jit, jacrev, jacfwd

#@jit
def B_func(R, phi, Z, X_coil, Y_coil, Z_coil, d_X_d_phi_coil, d_Y_d_phi_coil, d_Z_d_phi_coil, I, factor, B0, R0):
    """
    Pure function for computing B from a helical coil, in a form that is convenient for automatic differentiation.
    """
    #print("BR_Bphi_BZ called with R=%g, phi=%g, Z=%g" % (R, phi, Z))

    cosphi = jnp.cos(phi)
    sinphi = jnp.sin(phi)
    X = R * cosphi
    Y = R * sinphi

    dX = X - X_coil
    dY = Y - Y_coil
    dZ = Z - Z_coil

    r2 = dX * dX + dY * dY + dZ * dZ
    one_over_r3 = 1 / (r2 * jnp.sqrt(r2))

    # Biot-Savart law:
    BX = factor * jnp.sum(I * jnp.sum(one_over_r3 * (d_Y_d_phi_coil * dZ - d_Z_d_phi_coil * dY), axis=0))
    BY = factor * jnp.sum(I * jnp.sum(one_over_r3 * (d_Z_d_phi_coil * dX - d_X_d_phi_coil * dZ), axis=0))
    BZ = factor * jnp.sum(I * jnp.sum(one_over_r3 * (d_X_d_phi_coil * dY - d_Y_d_phi_coil * dX), axis=0))

    # Convert to cylindrical components:
    BR   =  BX * cosphi + BY * sinphi
    Bphi = -BX * sinphi + BY * cosphi + B0 * R0 / R
    # In that last term we add the toroidal field.

    return jnp.array([BR, Bphi, BZ])

#grad_B_autodiff = grad(B_func, argnums=(0,1,2))
grad_B_autodiff = jit(jacrev(B_func, argnums=(0,1,2)))
#grad_B_autodiff = jit(jacfwd(B_func, argnums=(0,1,2)))

class HelicalCoil(Field):
    """
    This class represents a magnetic field generated by one or more
    helical coils.
    """
    def __init__(self, m0=5, l0=2, B0=1, R0=1, r=0.3, n2pi=2, nphi=400,
                 I=np.array([-1, 1]) * 0.021, A=[[0, np.pi/2]], B=[[0, 0]]):
        self.m0 = m0
        self.nfp = m0
        self.l0 = l0
        self.B0 = B0
        self.R0 = R0
        self.r = r
        self.n2pi = n2pi
        self.nphi = nphi
        self.I = np.array(I)
        self.A = np.array(A)
        self.B = np.array(B)

        self.update()

    def update(self):
        """
        Does some initialization required before computing B.
        """
        assert self.A.shape == self.B.shape
        assert len(self.I) == self.A.shape[1]
        
        self.ncoils = len(self.I)
        self.phi = np.linspace(0, 2 * np.pi * self.n2pi, self.nphi, endpoint=False)
        self.dphi = self.phi[1] - self.phi[0]
        phi_big = np.kron(np.ones((self.ncoils, 1)), self.phi).transpose()
        cosphi = np.cos(phi_big)
        sinphi = np.sin(phi_big)
        eta = np.zeros((self.nphi, self.ncoils))
        d_eta_d_phi = np.zeros((self.nphi, self.ncoils))
        # eta(phi) is defined in eq (6) of Hanson & Cary (1984).
        for jcoil in range(self.ncoils):
            eta[:, jcoil] = self.m0 * self.phi / self.l0 + self.A[0, jcoil]
            d_eta_d_phi[:, jcoil] = self.m0 / self.l0
            for k in range(1, self.A.shape[0]):
                fac = k * self.m0 / self.l0
                eta[:, jcoil] += self.A[k, jcoil] * np.cos(fac * self.phi) \
                    + self.B[k, jcoil] * np.sin(fac * self.phi)
                d_eta_d_phi[:, jcoil] += -self.A[k, jcoil] * np.sin(fac * self.phi) * fac \
                    + self.B[k, jcoil] * np.cos(fac * self.phi) * fac
        coseta = np.cos(eta)
        sineta = np.sin(eta)
        self.R_coil = self.R0 + self.r * coseta
        self.X_coil = self.R_coil * cosphi
        self.Y_coil = self.R_coil * sinphi
        self.Z_coil = -self.r * sineta
        self.d_X_d_phi_coil = self.R_coil * (-sinphi) + self.r * (-sineta) * d_eta_d_phi * cosphi
        self.d_Y_d_phi_coil = self.R_coil *   cosphi  + self.r * (-sineta) * d_eta_d_phi * sinphi
        self.d_Z_d_phi_coil = -self.r * coseta * d_eta_d_phi
        self.factor = self.dphi

    def BR_Bphi_BZ(self, R, phi, Z):
        """
        Return the cylindrical components of the magnetic field at a specified point.
        This subroutine only works for single points as arguments.
        """
        #print("BR_Bphi_BZ called with R=%g, phi=%g, Z=%g" % (R, phi, Z))
        
        cosphi = np.cos(phi)
        sinphi = np.sin(phi)
        X = R * cosphi
        Y = R * sinphi

        dX = X - self.X_coil
        dY = Y - self.Y_coil
        dZ = Z - self.Z_coil

        r2 = dX * dX + dY * dY + dZ * dZ
        one_over_r3 = 1 / (r2 * np.sqrt(r2))

        # Biot-Savart law:
        BX = self.factor * np.sum(self.I * np.sum(one_over_r3 * (self.d_Y_d_phi_coil * dZ - self.d_Z_d_phi_coil * dY), axis=0))
        BY = self.factor * np.sum(self.I * np.sum(one_over_r3 * (self.d_Z_d_phi_coil * dX - self.d_X_d_phi_coil * dZ), axis=0))
        BZ = self.factor * np.sum(self.I * np.sum(one_over_r3 * (self.d_X_d_phi_coil * dY - self.d_Y_d_phi_coil * dX), axis=0))

        # Convert to cylindrical components:
        BR   =  BX * cosphi + BY * sinphi
        Bphi = -BX * sinphi + BY * cosphi + self.B0 * self.R0 / R
        # In that last term we add the toroidal field.

        return (BR, Bphi, BZ)
        
        """
        # This next line returns B using the autodiff pure function:
        return B_func(R, phi, Z, self.X_coil, self.Y_coil,
                      self.Z_coil, self.d_X_d_phi_coil, self.d_Y_d_phi_coil,
                      self.d_Z_d_phi_coil, self.I, self.factor, self.B0, self.R0)
        """
        
    def grad_B(self, R, phi, Z):
        temp = grad_B_autodiff(R, phi, Z, self.X_coil, self.Y_coil,
                               self.Z_coil, self.d_X_d_phi_coil, self.d_Y_d_phi_coil,
                               self.d_Z_d_phi_coil, self.I, self.factor, self.B0, self.R0)
        return np.array(temp).transpose()

    """
    def grad_BR_Bphi_BZ(self, R, phi, Z):
        #print("BR_Bphi_BZ called with R=%g, phi=%g, Z=%g" % (R, phi, Z))

        cosphi = np.cos(phi)
        sinphi = np.sin(phi)
        X = R * cosphi
        Y = R * sinphi

        dX = X - self.X_coil
        dY = Y - self.Y_coil
        dZ = Z - self.Z_coil

        r2 = dX * dX + dY * dY + dZ * dZ
        one_over_r3 = 1 / (r2 * np.sqrt(r2))
        m3_over_r5 = -3 * one_over_r3 / r2
        
        # Biot-Savart law:
        d_BX_d_X = self.factor * np.sum(self.I * np.sum(m3_over_r5 * dX * (self.d_Y_d_phi_coil * dZ - self.d_Z_d_phi_coil * dY), axis=0))
        BX = self.factor * np.sum(self.I * np.sum(one_over_r3 * (self.d_Y_d_phi_coil * dZ - self.d_Z_d_phi_coil * dY), axis=0))
        BY = self.factor * np.sum(self.I * np.sum(one_over_r3 * (self.d_Z_d_phi_coil * dX - self.d_X_d_phi_coil * dZ), axis=0))
        BZ = self.factor * np.sum(self.I * np.sum(one_over_r3 * (self.d_X_d_phi_coil * dY - self.d_Y_d_phi_coil * dX), axis=0))

        # Convert to cylindrical components:
        BR   =  BX * cosphi + BY * sinphi
        Bphi = -BX * sinphi + BY * cosphi + self.B0 * self.R0 / R
        # In that last term we add the toroidal field.

        return (BR, Bphi, BZ)
    """
    @classmethod
    def optimized(cls, *args, **kwargs):
        """
        Return the optimized helical coil shape from Hanson & Cary (1984).
        """
        A = [[0, np.pi / 2], \
             [0, 0.224859], \
             [0, 0], \
             [0, -0.000856]]
        
        B = [[0, 0], \
             [0.243960, 0], \
             [0.026240, -0.026490], \
             [0.000856, 0]]

        hc = cls(A=A, B=B, *args, **kwargs)
        return hc

    @classmethod
    def I0307_optimized(cls, *args, **kwargs):
        """
        Return the optimized helical coil shape from figure 3 and table 1
        of Cary & Hanson (1986).
        """
        A = [[0, np.pi / 2], \
             [0, 0.298089]]
        
        B = [[0, 0], \
             [0.298089, 0]]

        hc = cls(I=np.array([-1,1])*0.0307, A=A, B=B, *args, **kwargs)
        return hc
